r"""
Pandoc class
"""
import json
import subprocess


class Pandoc:
    """
    Execute external pandoc command as a subprocess to parse a source md file
    to generate PandocAST json object.
    """

    _version: dict[str, list[int | str]] | None
    _version_str: str | None
    _pandoc_command: str

    def __init__(self, pandoc_command: str = "pandoc"):
        self._version = None
        self._version_str = None
        self._pandoc_command = pandoc_command

    def _run(
        self, commandlines: list[list[str]], stdin=None
    ) -> tuple[list[int], str, list[str]]:
        """run multiple subcommands
        run multiple subcommands while connecting them with pipes and return results.

        @param commandlines (list[list[str]]) : _description_
        @param stdin (_type_, optional) : _description_. Defaults to None.

        @return tuple[list[int], str, list[str]] : _description_
        """
        retcode: list[int] = []
        stderr: list[str] = []
        output: str = ""

        with subprocess.Popen(
            commandlines[0],
            stdin=stdin,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            encoding="utf-8",
        ) as ps:
            serr: str

            if len(commandlines) > 1:
                retcode, output, stderr = self._run(commandlines[1:], stdin=ps.stdout)
                _, serr = ps.communicate()
            else:
                output, serr = ps.communicate()

            stderr.insert(0, serr)
            retcode.insert(0, ps.returncode)

        return retcode, output, stderr

    def get_json(
        self, filepath: str, fileformat: str | None = None, via_html: bool | None = None
    ):
        """
        returns pandoc ast json object.
        @param filepath : str
            File path to the source document to read.
        @param fromType : str / None
            Input filetype to be passed to pandoc with opt '-f'.
        @param html : bool / None
            Flag to specify whether or not to interpret html tags.
        @return output : { PandocAst Object }
            Pandoc AST json object generated by pandoc from source document.
        """
        _SOURCEPOS_ = ["gfm", "commonmark", "commonmark_x"]

        filename: list[str] = filepath.rsplit("/", 1)[-1].rsplit(".", 1)
        file_ext: str = filename[-1] if len(filename) > 1 else ""

        if (fileformat is None) and (file_ext == "md"):
            fileformat = "gfm+sourcepos"
            via_html = True if via_html is None else via_html
        else:
            if fileformat in _SOURCEPOS_:
                fileformat += "+sourcepos"
            via_html = False if via_html is None else via_html

        commands: list[list[str]] = []
        cmd: list[str] = [self._pandoc_command, filepath]

        if fileformat is not None:
            cmd += ["-f", fileformat]

        if not via_html:
            cmd += ["-t", "json"]
            commands.append(cmd)
        else:
            cmd += ["-t", "html"]
            commands.append(cmd)
            commands.append(
                [self._pandoc_command, "-f", "html", "-t", "json"],
            )

        json_object = json.loads(self._run(commands)[1])

        return json_object

    def get_version(self) -> dict[str, list[int | str]] | None:
        """
        returns versions of pandoc and pandoc-types.
        @return versions : {
                'pandoc': list[int | str],
                'pandoc-types': list[int | str],
            }
            version information obtained by 'pandoc --version'
        """
        if self._version is not None:
            return self._version

        stdout: str
        retcode: list[int]
        retcode, stdout, _ = self._run([[self._pandoc_command, "--version"]])

        version: dict[str, list[int | str]] = {}
        lines: list[str] = stdout.split("\n")
        line: str
        for line in lines:
            words: list[str] = line.replace(",", " ").split()
            for i, word in enumerate(words):
                if (word in ("pandoc", "pandoc-types")) and (i < len(words) - 1):
                    vers: list[str] = words[i + 1].split(".")
                    if not vers[0].isdecimal():
                        break
                    version[word] = [
                        (int(ver) if ver.isdecimal() else ver) for ver in vers
                    ]

        self._version = version
        self._version_str = stdout

        return self._version
